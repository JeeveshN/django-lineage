{"name":"Django Lineage","tagline":"Lightweight template tags for neater hierarchical navigation","body":"Handling which navigation element is active in a particular template can become\r\nannoying. Template blocks can be defined and later overriden to \"activate\" a\r\nclass on a particular navigational element, **but thats gets ugly!**\r\n\r\n**Lineage makes things neater** by defining your conditions centrally, and it\r\nlooks like this:\r\n\r\n    {% load lineage %}\r\n\r\n    <ul>\r\n        <li class=\"{% ancestor '/home/' %}\"><a href=\"/home/\">Home</a></li>\r\n        <li class=\"{% ancestor '/blog/' %}\"><a href=\"/blog/\">Blog</a></li>\r\n        <li class=\"{% ancestor '/about/' %}\"><a href=\"/about/\">About</a></li>\r\n    </ul>\r\n\r\nWhen an `ancestor` tag is evaludated, it compares it's argument to the page URL.\r\nIf the argument string matches the start of the current pages URL, it outputs\r\n\"active\". **It's that simple!**\r\n\r\nRead on for accepted arguments:\r\n\r\nInstallation\r\n------------\r\n\r\nInstall using pip:\r\n\r\n    pip install django-lineage\r\n\r\nAdd `'lineage'` to `INSTALLED_APPS` in `settings.py`:\r\n\r\n    INSTALLED_APPS = (\r\n        'lineage',\r\n    )\r\n\r\nUsage\r\n-----\r\n\r\nThe `ancestor` tag needs to, of course, be loaded into your template:\r\n\r\n    {% load lineage %}\r\n\r\nThe simplest way to use Lineage is the aformentioned `ancestor` tag. Again if\r\nthe argument matches the start of the page URL it outputs \"active\", this should\r\nhandle most use cases:\r\n\r\n    {% ancestor '/arbitrary/path/' %}\r\n\r\nBut wait... `ancestor` can also handle variables, filters and all that stuff:\r\n\r\n    {% ancestor some_variable|somefilter %}\r\n\r\nOr even full blown `url` tag type reverse resolution (Behind the scenes the\r\n`url` tag derives our expected argument - a URL path string.)\r\n\r\n    {% ancestor 'core:model_detail' model.pk %}\r\n\r\n### Active?\r\n\r\nBy default `ancestor` outputs \"active\" if it's argument matches the start of\r\nthe page URL. You can globally set the output of the `ancestor` tag by adding\r\n`LINEAGE_ANCESTOR_PHRASE = 'newphrase'` to `settings.py`\r\n\r\n### Advanced\r\n\r\nIf fine-grain control is what your after, you'll be looking for the\r\n`ifancestor/endifancestor` combo:\r\n\r\n    {% ifancestor 'pattern_name' %}\r\n        This text here is only renderd if the\r\n        URL argument is an ancestor.\r\n    {% endifancestor %}\r\n\r\nIt accepts the same exact arguments as `ancestor`, but allows you to define,\r\non a per definition basis, what the output will be.\r\n\r\n\r\nAssumptions\r\n-----------\r\n\r\nLineage depends on sensible URL hierarchies, because it compares paths using\r\nregex matching. The `{% ancestor '/base/' %}` tag will be true if the\r\ncurrent URL begins with that argument. For example `/base/` and `/base/section/page/`\r\nreturn true, but `/other/path/` and `/base` (missing trailing slash) will not.\r\n\r\n`request` must be present in the request context, since it's used to determine\r\nthe current URL. Django has [a context preprocessor][1] that can insert it for\r\nyou.\r\n\r\n[1]: https://docs.djangoproject.com/en/dev/ref/templates/api/#django-core-context-processors-request\r\n","google":"UA-32675598-4","note":"Don't delete this file! It's used internally to help with page regeneration."}